Variable P : Z -> bool.
Variable a : Z.
Goal (forall (x : Z), P x) -> P a.
Proof. verit. Qed.

(set-logic AUFLIA)
(declare-fun p (Int) Bool)
(declare-fun a () Int)
(assert (forall ((x Int)) (p x)))
(assert (not (p a)))
(check-sat)

Old Proof Format
----------------
1:(input ((forall  (x Int) (p x))))
2:(input ((not (p a))))
3:(tmp_betared ((forall  (@vr0 Int) (p @vr0))) 1)
4:(tmp_qnt_tidy ((forall  (@vr1 Int) (p @vr1))) 3)
5:(forall_inst ((or (not (forall  (@vr1 Int) (p @vr1))) (p a))))
6:(or ((not (forall  (@vr1 Int) (p @vr1))) (p a)) 5)
7:(resolution () 6 4 2)

SMTCOQ:
1:(input ((forall  (x Int) (p x))))
2:(input ((not (p a))))
3:(tmp_betared ((forall  (@vr0 Int) (p @vr0))) 1)
4:(tmp_qnt_tidy ((forall  (@vr1 Int) (p @vr1))) 3)
mk_clause(id=4,
          type=Tpqt,
          value=[]
          ids_params=[3])
5:(forall_inst ((or (not (forall  (@vr1 Int) (p @vr1))) (p a))))
mk_clause(id=5, 
          type=Fins, 
          value=(p a), 
          ids_params=[4])
6:(or ((not (forall  (@vr1 Int) (p @vr1))) (p a)) 5)
7:(resolution () 6 4 2)

New Proof Format
----------------
(assume h1 (forall ((x Int)) (p x)))
(assume h2 (not (p a)))(anchor :step t3 :args ((:= (x Int) h)))
(step t3.t1 (cl (= x h)) :rule refl)
(step t3.t2 (cl (= (p x) (p h))) :rule cong :premises (t3.t1))
(step t3 (cl (= (forall ((x Int)) (p x)) (forall ((h Int)) (p h)))) :rule bind)
(step t4 (cl (not (= (forall ((x Int)) (p x)) (forall ((h Int)) (p h)))) (not (forall ((x Int)) (p x))) (forall ((h Int)) (p h))) :rule equiv_pos2)
(step t5 (cl (forall ((h Int)) (p h))) :rule th_resolution :premises (h1 t3 t4))(anchor :step t6 :args ((:= (h Int) j)))
(step t6.t1 (cl (= h j)) :rule refl)
(step t6.t2 (cl (= (p h) (p j))) :rule cong :premises (t6.t1))
(step t6 (cl (= (forall ((h Int)) (p h)) (forall ((j Int)) (p j)))) :rule bind)(step t7 (cl (not (= (forall ((h Int)) (p h)) (forall ((j Int)) (p j)))) (not (forall ((h Int)) (p h))) (forall ((j Int)) (p j))) :rule equiv_pos2)
(step t8 (cl (forall ((j Int)) (p j))) :rule th_resolution :premises (t5 t6 t7))(step t9 (cl (or (not (forall ((j Int)) (p j))) (forall ((j Int)) (p j)))) :rule qnt_cnf)
(step t10 (cl (or (not (forall ((j Int)) (p j))) (p a))) :rule forall_inst :args ((:= j a)))
(step t11 (cl (not (forall ((j Int)) (p j))) (p a)) :rule or :premises (t10))
(step t12 (cl) :rule resolution :premises (t11 t8 h2))

Old Proof Format with Sharing
-----------------------------
1:(input (#1:(forall ( (x Int) ) #2:(p x))))
2:(input ((not #3:(p a))))
3:(tmp_betared (#4:(forall ( (@vr0 Int) ) #5:(p @vr0))) 1)
    mk_clause(id=3, type=Tpbr, (forall x', p x'), [1]) 
    |===> mk_scertif (Same (get_clause 1)) (Some (forall x', p x'))
    |===> mk_scertif (Same (mkRoot (forall x, p x))) (Some (forall x', p x'))
    |===> {Same (mkRoot (forall x, p x)), Some (forall x', p x')}
4:(tmp_qnt_tidy (#6:(forall ( (@vr1 Int) ) #7:(p @vr1))) 3)
    add_solver 6 (forall x'', p x'')
    add_ref 6 4
    mk_clause(id=4, type=Tpqt, value=[], ids_params=[3])
    |===> mk_scertif (Same (get_clause 3)) (Some [])
    |===> mk_scertif (Same {Same (mkRoot (forall x, p x)), Some (forall x', p x')}) (Some [])
    |===> {Same {Same (mkRoot (forall x, p x)), Some (forall x', p x')}, Some []}
5:(forall_inst (#8:(or (not #6) #3)))
    mk_clause(id=5, type=Fins, value=(p a), ids_params=[4](*get_ref 6*))
    |===> mk_scertif Other(Forall_inst (repr (get_clause 4), p a)) Some [p a]
    |===> mk_scertif Other(Forall_inst (repr ({Same {Same (mkRoot (forall x, p x)), Some (forall x', p x')}, Some []}, p a)) Some [p a]
    |===> {Other(Forall_inst (repr {Same {Same (mkRoot (forall x, p x)), Some (forall x', p x')}, Some []}, p a)), Some [p a]}
    |===> {Other(Forall_inst (repr {Same {Root, (forall x, p x)}, Some (forall x', p x')},                  p a)), Some [p a]}
    |===> {Other(Forall_inst (repr {Root, (forall x, p x)},                                                 p a)), Some [p a]}
    |===> {Other(Forall_inst ({Root, (forall x, p x)},                                                      p a)), Some [p a]}
6:(or ((not #6) #3) 5)
7:(resolution () 6 4 2)

New Proof Format with Sharing
-----------------------------
(assume h1 (! (forall ((x Int)) (! (p x) :named @p_2)) :named @p_1))
(assume h2 (not (! (p a) :named @p_10)))
(anchor :step t3 :args ((:= (x Int) h)))
(step t3.t1 (cl (= x h)) :rule refl)
(step t3.t2 (cl (= @p_2 (! (p h) :named @p_3))) :rule cong :premises (t3.t1))
(step t3 (cl (! (= @p_1 (! (forall ((h Int)) @p_3) :named @p_5)) :named @p_4)) :rule bind)
(step t4 (cl (not @p_4) (not @p_1) @p_5) :rule equiv_pos2)
(step t5 (cl @p_5) :rule th_resolution :premises (h1 t3 t4))
(anchor :step t6 :args ((:= (h Int) j)))
(step t6.t1 (cl (= h j)) :rule refl)
(step t6.t2 (cl (= @p_3 (! (p j) :named @p_6))) :rule cong :premises (t6.t1))
(step t6 (cl (! (= @p_5 (! (forall ((j Int)) @p_6) :named @p_8)) :named @p_7)) :rule bind)
(step t7 (cl (not @p_7) (not @p_5) @p_8) :rule equiv_pos2)
(step t8 (cl @p_8) :rule th_resolution :premises (t5 t6 t7))
(step t9 (cl (or (! (not @p_8) :named @p_9) @p_8)) :rule qnt_cnf)
(step t10 (cl (or @p_9 @p_10)) :rule forall_inst :args ((:= j a)))
(step t11 (cl @p_9 @p_10) :rule or :premises (t10))
(step t12 (cl) :rule resolution :premises (t11 t8 h2))


Quantified hypotheses are shallowly embedded as Props, but have no deep embedding. Proofs containing universally quantified formualas 
are used by SMTCoq only when the formulas are fully instantiated in the proof. Thus, SMTCoq only supports the `forall_inst` rule which 
has the form `QH -> Inst`, where `QH` is the quantified hypothesis of type Prop, and `Inst` is the instantiated quantifier-free formula 
of type `Bool`. SMTCoq translates the proof step `QH -> Inst` into `Inst`. To convert `QH -> Inst`, we need a proof of `QH`, and a proof 
of `QH -> Inst` (and then we apply modus ponens). We have a proof of `QH` since it is a hypothesis, and `QH -> Inst` is proved using a 
variant of the `auto` tactic.

From the following proof:
1:(input ((forall  (x Int) (p x))))
2:(input ((not (p a))))
3:(tmp_betared ((forall  (@vr0 Int) (p @vr0))) 1)
4:(tmp_qnt_tidy ((forall  (@vr1 Int) (p @vr1))) 3)
5:(forall_inst ((or (not (forall  (@vr1 Int) (p @vr1))) (p a))))
6:(or ((not (forall  (@vr1 Int) (p @vr1))) (p a)) 5)
7:(resolution () 6 4 2)
The final certificate checked by SMTCoq is:
~(p a)     (p a)
----------------
       []

Step 5: (forall x, p x) -> (p a) is converted into (p a)
    variant of `auto`	    Term from `intro`
------------------------	-----------------
(forall x, p x) -> (p a)	 (forall x, p x)
-----------------------------------------------
                   (p a)

Quantified goals are skolemized using `intro`.


SMTCoq
------
Parser Side-Effects                 AST                                                     Proof
                                    Root (forall x. p x)                                    1:(input ((forall  (x Int) (p x))))
                                    Root (~(p a))                                           2:(input ((not (p a))))
                                    Same (Root (forall x. p x))                             3:(tmp_betared ((forall  (@vr0 Int) (p @vr0))) 1)
add_ref (forall @vr1, p @vr1) 4     Same (Same (Root (forall x. p x)))                      4:(tmp_qnt_tidy ((forall  (@vr1 Int) (p @vr1))) 3)
get_ref (forall @vr1, p @vr1)       Fins (Root (forall x. p x, p a))                        5:(forall_inst ((or (not (forall  (@vr1 Int) (p @vr1))) (p a))))
                                    Same (Fins (Root (forall x. p x, p a)))                 6:(or ((not (forall  (@vr1 Int) (p @vr1))) (p a)) 5)
                                    Res 6 4 2 ---remove forall x. p x---> Res 6 2           7:(resolution () 6 4 2)
                                --> Res (Fins (Root (forall x. p x, p a)))  Root (~(p a))
                                --> Res (Root p a)  Root (~(p a))
                                --> ()


New Proof Format
----------------
(assume h1 (forall ((x Int)) (p x)))
(assume h2 (not (p a)))

;TODO 1: parse anchor as beginning of subproof, save end of subproof, allow arguments to add to context
(anchor :step t3 :args ((:= (x Int) h)))
;TODO 2: add refl, it allow it to check substitutions induced by the context
(step t3.t1 (cl (= x h)) :rule refl)
(step t3.t2 (cl (= (p x) (p h))) :rule cong :premises (t3.t1))
;TODO 3: implement as a no-op, and also as the end of the sub-proof
(step t3 (cl (= (forall ((x Int)) (p x)) (forall ((h Int)) (p h)))) :rule bind)
(step t4 (cl (not (= (forall ((x Int)) (p x)) (forall ((h Int)) (p h)))) 
    (not (forall ((x Int)) (p x))) (forall ((h Int)) (p h))) :rule equiv_pos2)

;TODO 4: if premises to reso contain bind and equiv_pos2, remove both premises
(step t5 (cl (forall ((h Int)) (p h))) :rule th_resolution :premises (h1 t3 t4))

(anchor :step t6 :args ((:= (h Int) j)))
(step t6.t1 (cl (= h j)) :rule refl)
(step t6.t2 (cl (= (p h) (p j))) :rule cong :premises (t6.t1))
(step t6 (cl (= (forall ((h Int)) (p h)) (forall ((j Int)) (p j)))) :rule bind)
(step t7 (cl (not (= (forall ((h Int)) (p h)) (forall ((j Int)) (p j)))) 
    (not (forall ((h Int)) (p h))) (forall ((j Int)) (p j))) :rule equiv_pos2)
(step t8 (cl (forall ((j Int)) (p j))) :rule th_resolution :premises (t5 t6 t7))

;TODO 5: implement as a no-op
(step t9 (cl (or (not (forall ((j Int)) (p j))) (forall ((j Int)) (p j)))) :rule qnt_cnf)
(step t10 (cl (or (not (forall ((j Int)) (p j))) (p a))) :rule forall_inst :args ((:= j a)))
(step t11 (cl (not (forall ((j Int)) (p j))) (p a)) :rule or :premises (t10))
(step t12 (cl) :rule resolution :premises (t11 t8 h2))

;How are subproofs currently handled?